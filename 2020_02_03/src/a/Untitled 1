
[this super]
this (메소드로 호출한)자기자신, 주체
 1) this() : 메소드 형식으로 호출(=생성자 호출), 생성자 이름을 직접적으로 호출 불가
 2) this.a : 주소(위치)를 표현= 레퍼런스, 인스턴스를 참조하고 있는것
   ex. a.b = a에 속홰있는 b 
super 기초클래스
 1) super()
 2) super.a : 주소(위치)를 표현 = 레퍼런스, 인스턴스를 참조하고 있는것

 1) -> 생성자와 연관
 2) -> 인스턴스의 멤버 변수에 연관
 
 this(), super() 둘다 써야할경우 ----> 생성자에서 일반 메소드를 만들어서 호출하도록 만든다
   중복적인 로직을 가지는 코드 구문이 나온다면 메소드화 시켜서 호출해서 사용하도록 만든다
    이 때 호출하는 메소드 : set, get, 생성자든 일반 메소드든 어디서든 사용가능
    
    
    
   ///////////////////////////
   
  멤버 변수 , 메소드 중복, 재정의 ++다형성 => 이번주 금or 다음주 월 
     기초클래스 = super, 부모 클래스 
  	age
  	addr
  	m1()
  	m2()
  	m2(int)
  	
     자식클래스 = 서브클래스      //기초클래스에서 서브클래스의 것을 가져올 수 X
 
	age 
	addr ****
    m1() 
    output()
    m2() ****
    /////
    age
    m1()
    m2(String)
    output(); *****
    	m2()
   
  /////////////////////////////////////////////////
  [ toString ]
  
  멤버변수가 가지고 있는 데이터에 대해서 추적해야할 떄
  매번 debug 돌리지 않고 정기적으로 저장된 logfile을 확인. 
  toString() === > overriding
  
      ---println( 인스턴스를 써주면(==레퍼런스 명 입력) ==> toString() 자동 호출 )   
      
  /////////////////////////////////////////////////
   [while 문]
  
  while(조건식 ) {
 	반복할 것 
 	   전후로 빠져나갈 문장이 필요
  }
  
  for, while 빠져나갈 때 break 
  
  
  //////////////////////////////////////
  
     [ 배열 (array) ]
     array == 평수 같은 아파트
  	동일한 자료형을 연속된 공간에 할당시켜 주는 것
  	주의 : 
  	
  	int []nums = new int[   수     ] 
  	
  	nums[ 인덱스 번호 ] = 데이타, 
 	  == num1 = 45;
  	  == num2 = 78;
  		위와 형식 같음==> 배열 : 정수들의 집합
  		
  	<에러 >   nums[28] =28;  ===> 범위 벗어남 , 참조변수 주소로부터 몇칸인지 생각하기
  		
  	class Test1{
  		String name;
  		String addr;
  	}
  	
  
  	
  	Test1 t1 = new Test1();   //  == int num1;
  	Test1 21 = new Test1();	  //  == int num2;
  	
  	Test1 [] ts = new Test1[ 2 ]
  	
  	ts[0] = new Test1();
  	
  	
  	
  	
  	
  	
     
     
     
     
     